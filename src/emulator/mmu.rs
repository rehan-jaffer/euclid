const BITMASK : u16 = 0xF000;
//use ansi_term::Colour::Red;
//use ansi_term::Colour::Green;
//use ansi_term::Style;

const BIOS : [u8; 256] = [
    0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26, 0xFF, 0x0E,
    0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0,
    0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
    0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
    0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99, 0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20,
    0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
    0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
    0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62, 0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06,
    0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xF2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
    0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17,
    0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9, 0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,
    0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
    0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
    0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E, 0x3c, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x4C,
    0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20,
    0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x20, 0xFE, 0x3E, 0x01, 0xE0, 0x50
];

/*
*  MMU Memory Map
*
* [Cartridge is loaded here]
* [0x0000->0x4000] 16kb ROM Bank #0
* [0x4000->0x8000] 16kb switchable ROM Bank
*
* [0x8000->0xA000] 8kb switchable RAM bank
* [0xA000->0xC000] 8kb Internal RAM
* [0xC000->0xE000] Sprite Attribute Memory (OAM)
* [0xE000->0xFE00] Empty but usable for I/O
* [0xFE00->0xFF4C] I/O Ports
* [0xFF4C->0xFF80] Empty but usable for I/O
* [0xFF80->0xFFFF] Internal RAM (stack memory etc.)
*/

impl<'a> MMU<'a> {
    pub fn rb(&self, addr : u16) -> u8 { 

      // mask the address and find the correct memory mapped region to read from
      match (addr & BITMASK) {
        0x0000 => {
          if (addr < 256) {
            return self.bios[addr as usize];
          }
          return self.rom[addr as usize];
        },
        0x1000 | 0x2000 | 0x3000 => {
            return self.rom[addr as usize];
        },
	    0x4000 | 0x5000 | 0x6000 | 0x7000 => {
            return self.rom[addr as usize];
        },
        _ => { return self.wram[addr as usize] }
      }

    }

    pub fn show_stack(&self, stack_pointer : u16) {
      if !self.stack_debugger_enabled { return () }
/*
      print!("[{:x?}] \t[ ", stack_pointer);
      for i in (0..16) {
        let addr = 65073-i;
        if (addr == stack_pointer) {
          print!("{}  ", Style::new().bold().paint(format!("*0x{:x?}*", self.wram[addr as usize])));
        } else {
          print!("{}  ", Green.paint(format!("0x{:x?}", self.wram[addr as usize])));        }
      }
      print!("] \r\n");*/
    }

    pub fn rw(&self, addr : u16) -> u16 {
      let word : u16 = ((self.rb(addr+1) as u16) << 8) + self.rb(addr) as u16;
      return word;
    }

    pub fn mem_region(&self, addr : u16) -> &str {
      match (addr & BITMASK) {
        0x0000 => {
          if (addr < 256) {
            return "BIOS";
          }
          return "ROM";
        },
        0x1000 | 0x2000 | 0x3000 => {
          return "ROM";
        },
        0x4000 | 0x5000 | 0x6000 | 0x7000 => {
          return "ROM";
        },
        0x8000 => {
          return "VRAM"
        }
        _ => { return "WRAM" }
      }      
    }

    pub fn wb(&mut self, addr : u16, value : u8) {

        // mask the address and find the correct memory mapped region to read from
        match (addr & BITMASK) {
          0x0000 => {
            if (addr < 256) {
                self.bios[addr as usize] = value;
            }
            self.rom[addr as usize] = value;
          },
          0x1000 | 0x2000 | 0x3000 => {
              self.rom[addr as usize] = value;
          },
          0x4000 | 0x5000 | 0x6000 | 0x7000 => {
              self.rom[addr as usize] = value;
          },
          0x8000 => {
            self.gpu.vram[(addr & 0x1FFF) as usize] = value;
          }
          _ => { self.wram[addr as usize] = value; }
        }      
        return;
    }

    pub fn ww(&mut self, addr : u16, word : u16) {
      let bytes = word.to_be_bytes();
      self.wb(addr+1, bytes[0]);
      self.wb(addr, bytes[1]);
    }

    pub fn load(&mut self) {
//      self.rom = bytes.clone();
        self.rom = Vec::new();
        for _ in 0..65536 {
          self.rom.push(0);
        }
    }

    pub fn load_bios(&mut self) {
      self.bios = BIOS.clone().to_vec();
    }
  }

pub struct MMU<'a> {
    pub bios: Vec<u8>,
    pub rom: Vec<u8>,
    pub eram: Vec<u8>,
    pub wram: Vec<u8>,
    pub zram: Vec<u8>,
    pub booting: bool,
    pub gpu: &'a mut super::gpu::GPU,
    pub stack_debugger_enabled: bool
  }